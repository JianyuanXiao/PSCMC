(define (extra-complex-type-to-list type)
  ;(write type current-error-port) (newline current-error-port)
  (cond
    ((pair? type) type); (apply append (map extra-complex-type-to-list type))
    (else
      (define s1l (string->list (to-string type))) 
      (let self ((s1l s1l) (curtp '()) (typst '()))
	(patmatch s1l
	  ((quo_- . y) (guard (isinlst quo_- '(#\space #\-))) (self y '() (cons (string->symbol (list->string (reverse curtp))) typst)))
	  (('#\* . y) 
	    (self y '() 
	      (if (null? curtp)
		(cons '* typst) 
		(lcons '* (string->symbol (list->string (reverse curtp))) typst))))
	  ((x . y) (self y (cons x curtp) typst))
	  (x (reverse (if (null? curtp) typst (cons (string->symbol (list->string (reverse curtp))) typst))))
	  ))))
  ;(list->string (map (lambda (x) (if (eq? x #\-) #\space x)) s1l))
)
(define (pass2_add_implicit_begins l1)
  (let self ((l1 l1))
    (patmatch l1
    (('defun name rettype arglst . body)
      `(defun ,name ,rettype ,arglst ,(self `(begin . ,body)))
      )
    ((block-or-cblock . y) (guard (isinlst block-or-cblock '(block cblock)))
      `(,block-or-cblock ,(self `(begin . ,y)))
      )
    (('for e0 p0 plusplus . body)
      `(for ,e0 ,p0 ,plusplus (block ,(self `(begin . ,body))))
      )
    (('paraforn veclen g e0 p0 . body)
      `(paraforn ,veclen ,g ,e0 ,p0 (block ,(self `(begin . ,body))))
      )
    (('inner-for-from-to var from to . body)
      `(inner-for-from-to ,var ,from ,to (block ,(self `(begin . ,body))))
      )

    ((x . y) (map self l1))
    (x x))
    )
  )
(define (pass3_remove_declare-and_define- l1)
  (let self ((l1 l1))
    ;(write l1 current-error-port) (newline current-error-port)
    (patmatch l1
      (('declare ('function-pointer ret . paratypes) name)
       (define appd (if (pair? name) (list (self `(set! ,(car name) ,(cadr name)))) '()))
       (define realname (if (pair? name) (car name) name))
	(append `(begin (dec-fun0 ,(extra-complex-type-to-list ret) ,(map extra-complex-type-to-list paratypes) ,realname)) appd)
	)
      ;(('declare ('find-type x) . y) )
      (('declare type . y)
	(define exedtype (extra-complex-type-to-list type))
	(cons 'begin (map (lambda (x) (if (pair? x) `(declare ,exedtype ,(self x)) `(declare ,exedtype ,x))) y))
	)
      (('sizeof type) 
	`(sizeof ,(extra-complex-type-to-list type))
	)
      (('typedef type newname)
	`(typedef ,(extra-complex-type-to-list type) ,newname)
	)
      (('extern type arg)
	`(extern ,(extra-complex-type-to-list type) ,arg)
	)
      ((declares . y) (guard (isdeclare? declares))
	(define type (get-type-declare declares))
	(patmatch y
	  (((var init) . z) 
	    ;(if (eq? var 'blas_dot_kernel) (begin (write (list var type) current-error-port) (write-string "\n" current-error-port)))
	    (self `(begin (declare ,type (,var ,init)) (,declares . ,z)))
	    )
	  ((var . z)
	    (self `(begin (declare ,type ,var) (,declares . ,z)))
	    )
	  (x '())
	  )
	)
      (('dec-array type name . lenxs)
	`(dec-array ,(extra-complex-type-to-list type) ,name . ,lenxs)
	)
      (('dec-local-array type name . numele)
	(set! type (extra-complex-type-to-list type))
	(case output_method
	  ('OpenCL `(dec-array ,(cons '__private type) ,name . ,numele))
	  ('SWMC `(dec-array ,(cons 'volatile type) ,name . ,numele))
	  (else `(dec-array ,type ,name . ,numele))
	  )
	)
      (('dec-local_shared-array type name . numele)
	(set! type (extra-complex-type-to-list type))
	(case output_method
	  ('OpenCL `(dec-array ,(cons '__local type) ,name . ,numele))
	  ('CUDA `(dec-array ,(cons '__shared__ type) ,name . ,numele))
	  ('HIP `(dec-array ,(cons '__shared__ type) ,name . ,numele))
	  ('SYCL `(dec-array ,(cons '__shared__ type) ,name . ,numele))
	  ('SWMC `(dec-array ,(cons 'volatile type) ,name . ,numele))
	  (else `(dec-array ,type ,name . ,numele))
	  )
	)
      (('type-convert newtype expr)
	`(type-convert ,(extra-complex-type-to-list newtype) ,(self expr))
	)
      (('typedef-struct name . decs)
	`(typedef-struct ,name . 
	   ,(map 
	      (lambda (x) 
		(patmatch x
		  (('dec-array . z) (self x))
		  ((type var) (cadr (self `(declare ,type ,var))))
		  (x x)
		  )
		) decs)
	   )
	)
      ((defun/dec-fun name rettype vars . body) (guard (isinlst defun/dec-fun '(defun dec-fun)))
	(cond
	  ((or (null? rettype) (and (pair? rettype) (pair? (car rettype)))) 
	    (write-string (concat (concat "Error function: " name) "\n") current-error-port) 
	    (car 0))
	  (else 0)
	  )
	(define arg-types (map (lambda (x) (list (extra-complex-type-to-list (car x))(cadr x))) vars))
	(define rttex (extra-complex-type-to-list rettype))
	(if (eq? defun/dec-fun 'defun)
	  `(defun ,name ,rttex ,arg-types ,(self (car body)))
	  `(dec-fun ,name ,rttex ,arg-types)
	  )
	)
      ((defines y . init) (guard (isdefine? defines))
	(define type (get-type-define defines))
	;(write-string (concat (symbol->string type) " haha\n") current-error-port)
	(self 
	  (cond
	    ((null? init)
	      `(declare ,type ,y)
	      )
	    (else
	      `(declare ,type (,y . ,init))
	      )
	    ))
	)
      ((funs . y) (map self l1))
      (x x)
      ))
  )
(define (pass55_move_local_memory_declarations l1)
  (define (gengensym pfx)
    (define n -1)
    (lambda ()
      (set! n (+ n 1))
      (concat pfx (number->string n))
      )
    )
  (define gensym35 (gengensym '__GEN7_))
  (define env-out '())
  (let self ((l1 l1) (env '()))
    ;(write l1 current-error-port) (newline current-error-port)
    (patmatch l1
      (('kernel ('defun name '(void) paras body))
	(set! env-out '())
	(define new-body (self body (list (fast-make-single-env-from-var-and-val '((g7161606_91-ata1335 . cd))))))
	`(kernel (defun ,name (void) ,paras (begin (local_shared-variables . ,env-out) ,new-body)))
	)
      (('kernel-with-xlen the-xlen ('defun name '(void) paras body))
	(set! env-out '())
	(define new-body (self body (list (fast-make-single-env-from-var-and-val '((g7161606_91-ata1335 . cd))))))
	`(kernel-with-xlen ,the-xlen (defun ,name (void) ,paras (begin (local_shared-variables . ,env-out) ,new-body)))
	)
      (('begin x) (list 'begin (self x env )))
      (('begin x . y) `(begin ,(self x env ) . ,(cdr (self `(begin . ,y) env))))
      (('block x) `(block ,(self x (cons (fast-make-single-env-from-var-and-val '((g7161606_91-ata1335 . cd))) env) )))
      (('dec-array ('__shared__ . type) name . nums) (guard (not (null? env)))
	(define newsym (gensym35))
	(define newname (concat newsym name))
	(add-binding-in-single-env (cons name newname) (car env))
	(set! env-out (cons (list newname type nums) env-out))
	;`(dec-array (__shared__ . ,type) ,name . ,nums)
	'()
	)
      ((x . y) (map (lambda (x) (self x env)) l1))
      (x (guard (and (symbol? x) (not (eq? (find-var-in-multi-env x env) varnotbound))))
	(define newname (find-var-in-multi-env x env))
	(if (eq? newname varnotbound) x `("&" (vector-ref ,newname 0)))
	)
      (x x)
      )
    )
  )
(define (pass1_remove_kernelfun_and_2if l1)
  ;(write GLOBAL_PREFIX current-error-port) (newline current-error-port)
  (define (genname n) (if (eq? GLOBAL_PREFIX "") n (concat GLOBAL_PREFIX n)))
  (let self ((l1 l1))
    (patmatch l1
      (('defkernel-with-xlen the-xlen name paras . body)
	(define mid-proc `((declare-const-long (__idx ,g_idx) (__idy ,g_idy) (__xlen ,g_xlen) (__ylen ,g_ylen) (__global_idx ,g_global_idx))))
	`(kernel-with-xlen ,the-xlen (defun ,name void ,paras . ,(append mid-proc (map self body))))
	)
      (('defkernel name paras . body)
	(define mid-proc `((declare-const-long (__idx ,g_idx) (__idy ,g_idy) (__xlen ,g_xlen) (__ylen ,g_ylen) (__global_idx ,g_global_idx))))
	;(if (eq? output_method 'OpenCL) (set! mid-proc (append (map (lambda (x) (list (concat 'declare- (cdr x)) (list (car x) `(vector-ref ,(concat (car x) const_arg_endfix) 0)))) const_args) mid-proc)) 0)
	`(begin
	   (kernel (defun ,name void ,paras . ,(append mid-proc (map self body))))
	   (sw-debug-ifdefmacro
	     (defun ,(multi-concat name '_ACCELERACTOR_DEBUG) void () 
	       ;(vector-set! STATE_ARR_ACC_DEBUG ,g_current_compute_unit_id 0)
	       (,(multi-concat (genname name) "_scmc_kernel"))
	       (vector-set! ,(multi-concat GLOBAL_PREFIX 'STATE_ARR_ACC_DEBUG) ,g_current_compute_unit_id 1)
	       )
	     ()
	     )
	   )
	)
      (('add-prefix name) 
	(cond
	  ((pair? name) 
	    (define ot (get_core_typename name))
	    (define nt (genname ot))
	    (replace-all name ot nt)
	    ) 
	  (else
	    (genname name)
	    )
	  )
	) 
      ((mulop x y z . a) (guard (isinlst mulop '(+ * b-xor b-and b-or and or semicolon)))
	(self `(,mulop ,x (,mulop ,y ,z . ,a)))
	)
      (('if p0 e1) (self `(if ,p0 ,e1 0)))
      ((x . y) (map self l1))
      (x x)
      )
    )
  )
(define (get-type-md-array var env)
  (let self ((var var) (env env))
    (patmatch var
      (('vector-ref v n)
	(define tp (self v env))
	(if (eq? tp varnotbound) varnotbound (cdr tp))
	)
      ((addmul x y) (guard (isinlst addmul operator-2s-lst))
	(define type-x (self x env))
	(define type-y (self y env))
	(cond
	  ((and (eq? type-x varnotbound) (eq? type-y varnotbound)) varnotbound)
	  ((eq? type-y varnotbound) type-x)
	  ((eq? type-x varnotbound) type-y)
	  (else 
	    (write-string "Error: two md arrays in one pointer express! " current-error-port)
	    (write var current-error-port)
	    (write-string "\n" current-error-port)
	    (car 0)
	    )
	  )
	)
      (var (guard (symbol? var))
	(define tp (find-var-in-multi-env var env))
	(if (eq? tp varnotbound) varnotbound tp)
	)
      (else varnotbound)
      )
    )
  )
(define (pass42_remove_multi_dimensional_array_for_some_compilers l1)
  (let self ((l1 l1) (env (list (fast-make-single-env-from-var-and-val init-env-lst))))
    (patmatch l1
      ;(('defun name rettype arg-types body))
      ((block-or-cblock body) (guard (isinlst block-or-cblock '(block cblock)))
	`(,block-or-cblock ,(self body (cons (fast-make-single-env-from-var-and-val (list '(g161606_91-ata1335 . cd))) env)))
	)
      ((decarray type name . lenxs) (guard (and (isinlst decarray '(dec-local-array dec-array dec-local_shared-array)) (> (length lenxs) 1)))
	(add-binding-in-single-env (cons name lenxs) (car env))
	`(,decarray ,type ,name (* . ,lenxs))
	)
      (('vector-ref var n)
	(define tp (get-type-md-array var env))
	(cond
	  ((eq? tp varnotbound) l1)
	  ((and (pair? tp) (null? (cdr tp)))
	    `(vector-ref ,(self var env) ,n)
	    )
	  ((pair? tp)
	    `(+ ,(self var env) (* . ,(cons n (cdr tp))))
	    )
	  (else
	    (write-string "Error in md array:" current-error-port)
	    (write l1 current-error-port)
	    (write-string "\n" current-error-port)
	    (car 0)
	    )
	  )
	)
      ((x . y) 
	(map (lambda (x) (self x env)) l1))
      (x x)
      )
    )
  )
(define pass4_num -1)
(define (pass4_remove_define l1)
  (set! pass4_num (+ pass4_num 1))
  (let self ((l1 l1) (env (list (fast-make-single-env-from-var-and-val init-env-lst))) (cont 'e))
 ;   (write l1 current-error-port)
	;(write-string "\nOK HERE\n" current-error-port)
    (patmatch l1
      (('defun name rettype arg-types body)
	;(write (list name rettype) current-error-port) (newline current-error-port)
	(add-binding-in-single-env (cons name rettype) (car env))
	;(write arg-types current-error-port) (newline current-error-port)
	;(define arg-types (map (lambda (x) (cons (cadr x) (extra-complex-type-to-list (get-type-declare (concat 'declare- (car x)))))) vars))
	(define newenv (cons (fast-make-single-env-from-var-and-val (map (lambda (x) (cons (cadr x) (car x))) arg-types)) env))
	;(write-string "OK HERE\n" current-error-port)
	`(defun ,name ,rettype ,arg-types ,(self body newenv cont))
	)
      (('declare type (x init))
	;(if (eq? x 'blas_dot_kernel_aaaaaaaaa) (begin (write 'p4 (list x type) current-error-port) (write-string "\n" current-error-port)) 0)
	(add-binding-in-single-env (cons x type) (car env))
	`(declare ,type (,x ,(self init env 'v))) 
	)
      ((block-or-cblock body) (guard (isinlst block-or-cblock '(block cblock)))
	`(,block-or-cblock ,(self body (cons (fast-make-single-env-from-var-and-val (list '(ffa812-1273 . cd))) env) cont))
	)
      (('inner-for-from-to var from to ('block body))
	;(add-binding-in-single-env (cons var '(int)) (car env))
	`(inner-for-from-to ,var ,from ,to (block ,(self body (cons (fast-make-single-env-from-var-and-val (list (cons var '(int)))) env) cont)))
	)
      (('paraforn vlen var from to ('block body))
	;(add-binding-in-single-env (cons var '(int)) (car env))
	`(paraforn ,vlen ,var ,from ,to (block ,(self body (cons (fast-make-single-env-from-var-and-val (list (cons var '(int)))) env) cont)))
	)
      (('declare ('find-type name) . dec) (guard (>= pass4_num 1))
	(self `(declare ,(find-type name env) . ,dec) env cont)
	)
      (('declare type x)
	(add-binding-in-single-env (cons x type) (car env))
	l1
	)
      (('dec-array ('find-type name) . dec) (guard (>= pass4_num 1))
	(write name current-error-port) (newline current-error-port)
	(write (find-type name env) current-error-port) (newline current-error-port)
	(self `(dec-array ,(find-type name env) . ,dec) env cont)
	)
      (('dec-array type name . lenxs)
	(add-binding-in-single-env (cons name (reverse (append (map (lambda (x) '*) lenxs) (reverse type)))) (car env))
	l1
	)
      (('find-type arg) (find-type arg env))
      (('define x y) 
	;(write l1 current-error-port) (newline current-error-port)
	(define type (find-type y env))
	;(write type current-error-port) (newline current-error-port)
	(if (eq? type varnotbound) (error-h "Error: unable to decide the type: " (list x y)) 0)
	(add-binding-in-single-env (cons x type) (car env ))
	`(declare ,type (,x ,(self y env cont) ))
	)
      ((x . y) (map (lambda (x) (self x env cont)) l1))
      (x x)
      )
    )
  )
(define (pass45_remove_c99_non_first_block_declare_for_some_compilers l1)
  ;(write-string "called \n")
  (let self ((l1 l1))
    ;(write l1 current-error-port) (write-string "\n" current-error-port)
    (patmatch l1
      ;(('block . y) (define newy (self `(begin . ,y))) (if (and (pair? newy) (eq? (car newy) 'begin)) (set! newy (cdr newy)) (set! newy (list newy))) `(block . ,newy))
      ;(('begin ('force-simd-ver . g) . y) (self (append)))
      (('begin (begin-simd . g) . y) (guard (isinlst begin-simd '(begin force-simd-ver)))
	(self (append `(begin) g y))
	)
      (('begin ('dec-array . decs) . y) 
	;(write decs current-error-port) (write-string "dec-array here\n" current-error-port)
	`(block (begin (dec-array . ,decs) ,(self `(begin . ,y)))))
      (('begin ('declare . decs) . y)
	;(write decs current-error-port) (write-string "declare here\n" current-error-port)
	`(block (begin (declare . ,decs) ,(self `(begin . ,y))))
	)
      (('begin x) (self x))
      (('begin x . y)
	(define newy (self `(begin . ,y)))
	(if (and (pair? newy) (eq? (car newy) 'begin))
	  (set! newy (cdr newy))
	  (set! newy (list newy))
	  )
	`(begin ,(self x) . ,newy)
	)
      ((x . y)
	;(write x current-error-port) (write-string "no-declare\n" current-error-port)
	(cons (self x) (self y))
	)
      (x x)
      ))
  ;(write l2 current-error-port) (write-string "\n" current-error-port)
  )

(define GLOBAL_PREFIX 'omp_)
(define (get_core_typename t)
  (let loop ((t (reverse t)))
    (cond
      ((null? t) varnotbound)
      ((eq? (car t) '*) (loop (cdr t)))
      (else (car t))
      )
    )
  )
(define (pass5_add_prefix l1)
  (define (genname n) (if (eq? GLOBAL_PREFIX "") n (concat GLOBAL_PREFIX n)))
  (let self ((l1 l1) (env (list (fast-make-single-env-from-var-and-val '( (tmp0112366-123ga . 0) )))) (cont 'g)) ;cont can be g(global) l(local)
    (define (gennewtype t)
      (map (lambda (x) (self x env 'l)) t)
      )
    (define (mapself x) (map (lambda (x) (self x env cont)) x))
    (define (gennewnametype nt)
      (define name (cadr nt))
      (define type (car nt))
      (list (gennewtype type) (self name env 'l))
      )
    (define (mapgennnt ntl)
      (map gennewnametype ntl)
      )
    (define (gennewnametype-str nt)
      (map (lambda (x) (self x env 'l)) nt)
      )
    (define (mapgennnt-str ntl)
      (map gennewnametype-str ntl)
      )
    (patmatch l1
      (('defun name rettype arg-types body) (guard (eq? cont 'g))
	(add-binding-in-single-env (cons name rettype) (car env))
	`(defun ,(genname name) ,(gennewtype rettype) ,(mapgennnt arg-types) ,(self body env 'l))
	)
      (('declare type (x init)) (guard (eq? cont 'g)) 
	(add-binding-in-single-env (cons x type) (car env))
	(define ot (get_core_typename type))
	(define nt (find-var-in-multi-env ot env))
	(if (eq? nt  varnotbound) 0 (set! type (replace-all type ot nt )))
	;(if (eq? x 'blas_dot_kernel_aaaaaaaaa) (begin (write 'p5 (list x type) current-error-port) (write-string "\n" current-error-port)) 0)
	`(declare ,type (,(genname x) ,(self init env 'l)))
	)
      ((mulop x y z . a) (guard (isinlst mulop '(+ * b-xor b-and b-or and or semicolon)))
	(self `(,mulop ,x (,mulop ,y ,z . ,a)) env cont)
	)
      (('vector-set! x n y) (self `(set! (vector-ref ,x ,n) ,y) env cont))
      (('add-prefix-all name)
	(add-binding-in-single-env (cons name (genname name)) (car env))
	'()
	)
      (('declare type x) (guard (eq? cont 'g))
	(add-binding-in-single-env (cons x type) (car env))
	(define ot (get_core_typename type))
	(define nt (find-var-in-multi-env ot env))
	(if (eq? nt  varnotbound)  0 (set! type (replace-all type ot nt )))
	`(declare ,type ,(genname x))
	)
      (('typedef-struct name . decs) (guard (eq? cont 'g))
	(add-binding-in-single-env (cons name (genname name)) (car env))
	`(typedef-struct ,(genname name) . ,(mapgennnt-str decs))
	)
      
      ((x . y) (mapself l1))
      (x (guard (symbol? x))
	(define nx (find-var-in-multi-env x env))
	(if (eq? nx varnotbound) x (genname x)
	  )
	)
      (x x)
      )
    )
  )
(define (isvectype tp)
  (eq? (car (reverse tp)) '*)
  )
(define (nullstrcons a b)
  (if (eq? a "") b (cons a b))
  )
(define (pass6-uncover-kernel-prefix l1)
  (define (gengensym pfx)
    (define n -1)
    (lambda ()
      (set! n (+ n 1))
      (concat pfx (number->string n))
      )
    )
  (define gensym6 (gengensym 'GEN6))
  (define (gen-local-sh-v obody)
    (patmatch obody
      (('begin ('local_shared-variables . lsvsg) b) (list lsvsg b))
      (x (list '() obody))
      )
    )
  (let self ((l1 l1))
    (patmatch l1
      (('kernel-with-xlen __xlen ('defun name rettype arglst body))
	(set! functiondefs (cons `(,(multi-concat 'IDX_ name '_XLEN) ,__xlen) functiondefs))
	;(write name current-error-port) (newline current-error-port)
	(self 
	  `(begin 
	     (pure-text ,(multi-concat "\n#ifdef IDX_LOCAL_XLEN\n#undef IDX_LOCAL_XLEN \n#endif\n#define IDX_LOCAL_XLEN " (number->string __xlen) "\n"))
	     (kernel (defun ,name ,rettype ,arglst ,body))))
	)
      (('kernel ('defun name rettype arglst obody))
	(multi-define l-s-vars body (gen-local-sh-v obody))
	(set! kernelfunctions (cons `(,name ,arglst) kernelfunctions))
	(define arglst1 arglst)
	(define arglst-ori arglst)
	(if (isinlst output_method '(C OpenMP COI))
	  (begin
	    (set! arglst1 (append arglst `(((long ) ,(if (eq? output_method 'COI) 'scmc_internal_g_xlen 'scmc_internal_g_idy)) ((long) scmc_internal_g_ylen))))
	    (set! arglst (append arglst `(((long ) scmc_internal_g_idy ) ((long) scmc_internal_g_ylen))))
	    (set! name (concat name '_scmc_kernel))
	  )
	  0
	  )
	(set! functiondefs (cons `(,name ,rettype ,arglst) functiondefs))
	(define global_fun_para_prefix '())
	(define exec_prefix '())
	(define newargs 0)
	(cond
	  ((eq? output_method 'SWMC)
	    (set! arglst (append arglst '(((long) scmc_internal_g_ylen))))
	    (set! global_fun_para_prefix 
	      (map 
		(lambda (tp-nm)
		  (multi-define tp nm tp-nm)
		  `(extern ,tp ,(multi-concat 'SWMC_ name '_ nm))
		  ) arglst 
		)
	      )
	    (set! exec_prefix 
	      (cons 'begin
	      (map 
		(lambda (tp-nm)
		  (multi-define tp nm tp-nm)
		  `(declare ,tp (,nm ,(multi-concat 'SWMC_ name '_ nm)))
		  ) arglst)))
	    (set! body 
	      `(block
		 (begin
		   (declare (long) swmc_idy)
		   (declare (long) SWMC_internal_idymin)
		   (declare (long) SWMC_internal_idymax)
		   (block 
		     (begin
		       (declare (long) (numt 64))
		       (for (set! swmc_idy (athread_get_id -1)) (< swmc_idy scmc_internal_g_ylen) swmc_idy+=numt
			 (block
			   ,body)
			 )))
		 )
	      ))
	    (set! newargs '())
	    (set! name (concat name '_scmc_kernel))
	    )
	  (else 
	    (set! newargs (map (lambda (x) (if (isvectype (car x)) (list (nullstrcons kernel_arg_prefix (car x)) (cadr x)) x)) arglst))
	    )
	  )
;	(write (list output_method g_current_compute_unit_id g_num_compute_unit) current-error-port) (newline)
;
	;(write output_method current-error-port) (newline current-error-port)

	;(write l-s-vars current-error-port) (newline current-error-port)
	(if (eq? output_method 'SYCL) ;( (null? l-s-vars))
	  (set! exec_prefix 
	    (lcons 'begin 
	      `(local_shared-vars . ,l-s-vars)
	      exec_prefix
	      ))
	  0
	  )
	
	`(begin 
	   ,(append '(begin) global_fun_para_prefix
	      `((defun ,name ,(nullstrcons kernel_fun_prefix rettype) 
		  ,newargs 
		  (begin ,exec_prefix 
		    (declare (const long) (pscmc_compute_unit_id ,g_current_compute_unit_id))
		    (declare (const long) (pscmc_num_compute_units ,g_num_compute_unit )) 
		    ,(self body)))))
	   ,(if (eq? output_method 'COI)
	      (begin
		(define numargs (length newargs))
		(define curvint -1)
		(define cursint -1)
		(define arg-vec '())
		(map 
		  (lambda (x) 
		    (multi-define type var x)
		    (if (isvectype type) (set! arg-vec (cons x arg-vec)) 0)) newargs)
		(set! arg-vec (reverse arg-vec))
		(define num-vec-args (length arg-vec))
		`(begin
		   (pure-text "\nCOINATIVELIBEXPORT\n")
		   (defun ,(concat name '_coi_kernel) (void) 
		     (((uint32_t) in_BufferCount) 
		       ((void * *) in_ppBufferPointers)
		       ((uint64_t *) in_pBufferLengths)
		       ((void * *) in_pMiscData)
		       ((uint16_t) in_MiscDataLength)
		       ((void *) in_pReturnValue)
		       ((uint16_t) in_ReturnValueLength)
		       )
		     (begin
		       (UNREFERENCED_PARAM in_BufferCount)
		       (UNREFERENCED_PARAM in_ppBufferPointers)
		       (UNREFERENCED_PARAM in_pBufferLengths)
		       (UNREFERENCED_PARAM in_pMiscData)
		       (UNREFERENCED_PARAM in_MiscDataLength)
		       (assert (eq? in_BufferCount 1))
		       (assert (eq? 4 in_ReturnValueLength))
		       (if (and (neq? in_pMiscData NULL) (neq? in_pReturnValue NULL))
			 (memcpy in_pReturnValue "OK!" in_ReturnValueLength)
			 0
			 )
		       (begin . 
			 ,(map 
			    (lambda (tp-var)
			      (multi-define type var tp-var)
			      (define isv (isvectype type))
			      (set! cursint (+ cursint 1))
			      (if isv
				(begin
				  `(declare ,type 
				     (,var (type-convert ,type (+ (type-convert (size_t) (vector-ref in_ppBufferPointers 0)) (vector-ref (type-convert (size_t *) (+ (type-convert (char *)  in_pMiscData) (* ,cursint 8))) 0)))))
				  )
				(begin
				  `(declare ,type
				     (,var 
				       (vector-ref (type-convert ,(append type '(*)) (+ (type-convert (char *)  in_pMiscData) (* ,cursint 8))) 0))
				     )
				  )
				)
			      ) arglst1))
		       (declare (const long) (pscmc_compute_unit_id ,g_current_compute_unit_id))
		       (declare (const long) (pscmc_num_compute_units ,g_num_compute_unit )) 
		       (ifdefmacro COI_NUM_THREADS
			 (omp_set_num_threads COI_NUM_THREADS)
			 ()
			 )
		       (pure-text "\n#pragma omp parallel\n")
		       (block
			 (begin
			   (declare (int) xid)
			   (declare (int) yid)
			   (declare (int) (numt (omp_get_num_threads)))
			   (declare (int) (tid (omp_get_thread_num)))
			   (declare (int) (ysingle (/ (+ scmc_internal_g_ylen (- numt 1)) numt)))
			   (declare (int) (ymin (* tid ysingle) )) 
			   (declare (int) (ymax (* (+ 1 tid) ysingle)))
			   (for (set! yid tid) (< yid scmc_internal_g_ylen) (set! yid (+ yid numt))
			     (block 
			       (begin
				 (for (set! xid 0) (< xid scmc_internal_g_xlen) (set! xid (+ xid 1))
				   (block 
				     (begin
				       ,(lcons name
					  (append (map cadr arglst-ori)
					    '(yid scmc_internal_g_ylen))))) 
				   )))))
			 ))
		     )
		   )) '()) 
	   )
	)
      (('paraforn veclen ivar from to body)
	(define alignlen 0)
	(define imm-env '())
	(define simd-len 1)
	(define main_fp_type 'double)
	(define mask_var #f)
	(define merge-loop #f)
	(if (pair? veclen)
	  (begin
	    (set! alignlen (cadr veclen))
	    (if (pair? (cddr veclen))
	      (begin
		(set! imm-env (caddr veclen))
		(if (pair? (cdddr veclen))
		  (begin
		    (set! simd-len (cadddr veclen))
		    (if (pair? (cdr (cdddr veclen)))
		      (begin
			(set! main_fp_type (cadr (cdddr veclen)))
			(define rest (cddr (cdddr veclen)))
			(if (pair? rest)
			  (begin
			    (set! mask_var (car rest))
			    (if (pair? (cdr rest))
			      (set! merge-loop (cadr rest))
			      0
			      )
			    0)
			  0
			  )
			)
		      0
		      )
		    ) 
		  0
		  )
		)
	      0
	      )
	    (set! veclen (car veclen))
	    )
	  0
	  )
	;(write imm-env current-error-port) (write-string "\n" current-error-port)
	;(write (list 'bef body) current-error-port) (write-string "\n" current-error-port)
	(define nbody 
	  (expand-parafor-cpu-simd ivar from to 
	    (if (eq? mask_var #f) body 
	      `(block
		 (begin
		   (declare (,main_fp_type) ,mask_var)
		   (set! ,mask_var (< ,ivar ,to))
		   ,body)
		 )
	      ) 
	    '() veclen alignlen imm-env simd-len main_fp_type)
	  )
	(set! veclen (* veclen simd-len))
	;(write (list 'aft nbody) current-error-port) (write-string "\n" current-error-port)
	(if merge-loop
	  `(block
	     (begin
	       (declare (long) ,ivar)
	       ;(pure-text ,(multi-concat "\n#pragma omp simd collapse(" (number->string veclen) ")\n"))
	       (for (set! ,ivar ,from) (< ,ivar ,to) (set! ,ivar (+ ,ivar ,veclen))
		 ,nbody
		 )
	       )
	     ) 
	  `(block
	     (begin
	       (declare (long) ,ivar)
	       ;(pure-text ,(multi-concat "\n#pragma omp simd collapse(" (number->string veclen) ")\n"))
	       (for (set! ,ivar ,from) (< ,ivar (- ,to (- ,veclen 1))) (set! ,ivar (+ ,ivar ,veclen))
		 ,nbody
		 )
	       ,(if (eq? mask_var #f)
		  `(for 0 (< ,ivar ,to) (set! ,ivar (+ ,ivar 1)) ,body) 
		  `(begin ,nbody) 
		  )
	       )
	     ))
	)
      (('defun name rettype arglst body)
	(set! functiondefs (cons `(,name ,rettype ,arglst) functiondefs))
	`(defun ,name ,(nullstrcons device_fun_prefix rettype) ,arglst ,(self body))
	)
      (('sync-local)
	(case output_method
	  ('OpenCL `(barrier CLK_LOCAL_MEM_FENCE))
	  ('CUDA `(__syncthreads))
	  ('HIP `(__syncthreads))
	  ('SYCL `(scmc_local_global_id.barrier sycl::access::fence_space::local_space))
	  (else '())
	  )
	)
      ((x . y) (map self l1))
      (x x)
      )
    )
  )
(define allpasses1 (list 
		      pass1_remove_kernelfun_and_2if pass2_add_implicit_begins pass3_remove_declare-and_define- 
		      pass4_remove_define pass5_add_prefix pass6-uncover-kernel-prefix pass4_remove_define
		      ))
(define (dbgproc l1)
  (let loop ((l1 l1) (ps allpasses1))
    (cond
      ((null? ps) l1)
      (else
	(loop ((car ps) l1) (cdr ps))
	)
      )
    )
  )
  (define functiondefs '())
  (define kernelfunctions '())
(define g_use_icc_simd #f)
(define (scmc_compile_pre_passes d1)
  (pre_eval_global)
  (define argv (list->vector (get-argv)))
  (if (> (vector-length argv) 6)
    (begin
      (define nst (vector-ref argv 6))
      (set! g_extra_compile_mode 
	(case nst
	  ("1" 1)
	  ("2" 2)
	  ("3" 3)
	  ("4" 4)
	  ("5" 5)
	  ("6" 6)
	  ("7" 7)
	  (else 0)
	  )
	)
      )
    0
    )
  ;(write-string "use pass 15=" current-error-port)

  (set! g_use_icc_simd (eq? (remainder (/ g_extra_compile_mode 4) 2) 1))
  (define use_pass42 (eq? (remainder (/ g_extra_compile_mode 2) 2) 1))
  ;(write (list g_extra_compile_mode (/ g_extra_compile_mode 2) use_pass42) current-error-port) (write-string "\n" current-error-port)
  (define allpasses 
    (append 
      (list pass1_remove_kernelfun_and_2if pass2_add_implicit_begins pass3_remove_declare-and_define- pass4_remove_define)
      (if use_pass42 (list pass42_remove_multi_dimensional_array_for_some_compilers) '())
      ;(if (eq? output_method 'SWMC) (list pass45_remove_c99_non_first_block_declare_for_some_compilers) '()) 
      (list pass5_add_prefix)
      (if (eq? output_method 'SYCL) (list pass55_move_local_memory_declarations) '())
      (list pass6-uncover-kernel-prefix pass4_remove_define) 
      (if (eq? (remainder g_extra_compile_mode 2) 1) 
	(list pass45_remove_c99_non_first_block_declare_for_some_compilers )
	'())
      ))
  (define nout 0)
  (define l2 
    (let loop ((l1 (read-all infile)) (ps allpasses))
      (cond
	((null? ps) l1)
	(else
	  (write nout current-error-port)
	  ;(if (eq? (car ps) pass6-uncover-kernel-prefix) (write-string "pass6 init\n" current-error-port) 0)
	  (set! nout (+ nout 1))
	  (define proced ((car ps) l1))
	  (write-string " done\n" current-error-port)
	  (loop proced (cdr ps))
	  )
	)
      )
    )
  ;(write "OK here\n" current-error-port)
  (if (> (vector-length argv) 5)
    (begin 
      (define fp (open-output-file (vector-ref argv 5))) 
      (write functiondefs fp) 
      (write kernelfunctions fp)
      
      ) 0)
  l2
  )
(define (readport fp)
  (define ad 
    (let loop ((l1 (read fp)))
      ;(write l1 current-error-port) (newline current-error-port)
      (cond
	((eof-object? l1) '())
	(else
	  (cons l1 (loop (read fp)))
	  )
	)
      )
    )
  ;(define a (read fp))
  (close-input-port fp)
  (cons 'begin ad)
  )
(define (readfile fn)
  (define fp (open-input-file fn))
  (readport fp)
  )
(define (isinlstequal x lst) (cond ((null? lst) #f) ((equal? x (car lst)) #t) ((and (pair? x) (equal? (car x) (car lst))) #t) ((and (pair? (car lst)) (equal? x (caar lst))) #t) (else (isinlstequal x (cdr lst)))))
;(define find-type-first-env (y env . vec-star) (apply find-type (lcons y )))
(define find-type 
  (named-lambda self (y env . vec-star)
    (define vstar (if (null? vec-star) '* (car vec-star)))
    ;(write-string "hehe\n")
    (patmatch y
      (x (guard (fixnum? x)) (fast-find-var-in-single-env 'fixnum simple-type-map))
      (x (guard (float? x)) (fast-find-var-in-single-env 'float simple-type-map))
      (x (guard (string? x)) (fast-find-var-in-single-env 'string simple-type-map))
      (x (guard (boolean? x)) (fast-find-var-in-single-env 'boolean simple-type-map))
      (x (guard (symbol? x)) (find-var-in-multi-env x env))
      ((leq . x) (guard (isinlst leq operator-booleans))
	(self #t env vstar)
)
      ((xor . y) (guard (isinlst xor integer-ops))
	(self 0 env vstar)
)
      ((addmul x y) (guard (isinlst addmul operator-2s-lst))
	;(write (list x  (self x env)))
	;(newline)
        (let ((typex (self x env vstar)) (typey (self y env vstar)) (ispointertp (lambda (tp) (and (pair? tp) (eq? (car (reverse tp)) vstar)))))
	  (cond
	    ((ispointertp typex)
	      (if (ispointertp typey) varnotbound typex)
	      )
	    ((ispointertp typey)
	      (if (ispointertp typex) varnotbound typey)
	      )
	    ((equal? typex typey)
	      typex
	      )
	    ((and (isinlstequal typex int-types) (isinlstequal typey int-types))
	      ;(write (list typex typey) current-error-port) (newline current-error-port)
	      (fast-find-var-in-single-env 'fixnum simple-type-map)
)
	    ((and (isinlstequal typex (append float-types int-types)) (isinlstequal typey (append float-types int-types)))
	      (fast-find-var-in-single-env 'float simple-type-map)
)
	    (else varnotbound ))
	;'(double)
	  )
	)
      ;(('get-pointer arg) ())
      (('vector-ref arg n) (define vectype (self arg env vstar)) 
	(if (or (eq? vectype varnotbound) (not (eq? (car (reverse vectype)) vstar))) varnotbound
	  (reverse (cdr (reverse vectype)))
	;(string->symbol (list->string (reverse (cdr (reverse (string->list (symbol->string vectype)))))))
	)
)
      ((x . rst) (find-var-in-multi-env x env))
      (x varnotbound)
)
))
(define int-types '(int unsigned-int long unsigned-long size_t ssize_t))
(define float-types '(float double))

(set! float-types (map list float-types))
(set! int-types (map list int-types))
(define simple-type-map 
  (fast-make-single-env-from-var-and-val 
    '((fixnum long) (float double) (string char*) (boolean int)))
)
(define (ifcontains_inner lst var)
  (cond
    ((null? lst) #f)
    ((pair? (car lst)) (or (ifcontains_inner (car lst) var) (ifcontains_inner (cdr lst) var)))
    ((eq? (car lst) var)  #t)
    (else (ifcontains_inner (cdr lst) var))
    )
  )
(define x86-64-avx2-type-map 
  '(
     (double __m256d)
     (long __m256i)
     (size_t __v4du)
     ;(float . )
     ))
(define x86-64-avx2-make-vector
  '(
     (double . a)
     )
  )


(define (ex-parafor-cpu-simd-old innervar varfrom varto body outenv numveclen alignlen type-map)
  (define type-env 
    (if (null? type-map)
      #f
      (fast-make-single-env-from-var-and-val type-map)))
  (define vec-prefix 'VPFX_)
  ;(define inner-var-simd (concat ))
  (let self ((body body) (env (list (fast-make-single-env-from-var-and-val `((funtmpsym_77101 v . int))))) (cont 'sca)) ;cont can be 'sca or 'vec
    ;(write (list body cont)) (newline)
    (patmatch body
      (('declare type (name init))
	(self `(begin (declare ,type ,name) (set! ,name ,init)) env cont)
	)
      ;(('declare type (name ini)))
      (('declare type name) (guard (eq? (car type) 'scalar))
	`(declare ,(cdr type) ,name)
	)
      (('declare type name)
	(add-binding-in-single-env (cons name (list type 'm-vv)) (car env))
	`(begin 
	   (dec-array ,(if (eq? alignlen 0) type (cons alignlen type)) ,name ,numveclen)
	   ,(if (not (eq? type-env #f)) 
	      (begin 
		(define newtype (fast-find-var-in-single-env (car (reverse type)) type-env))
		(if (eq? newtype varnotbound)
		  (error-h "Error: unknown type in declare " body)
		  0
		  )
		;(write newtype current-error-port) (write-string "\n" current-error-port)
		`(declare ,(append newtype '(*)) (,(concat vec-prefix name) ,name))
		)
	      '())
	   )
	)
      ((block-or-cblock ('begin . y)) (guard (isinlst block-or-cblock '(block cblock)))
        `(,block-or-cblock ,(self `(begin . ,y) (add-empty-env-layer env) cont))
	)
      (('dec-array type name . len)
	(add-binding-in-single-env (cons name (append (list type 'm-vv) (map (lambda (x) 'm-v) len))) (car env))
	`(begin
	   (dec-array ,(if (eq? alignlen 0) type (cons alignlen type)) ,name . ,(append len (list numveclen)))
	   ,(if (not (eq? type-env #f))
	      (begin
		(define newtype (fast-find-var-in-single-env (car (reverse type)) type-env))
		(define vpfx-name (concat vec-prefix name))
		(if (eq? newtype varnotbound)
		  (begin 
		    (error-h "Error: unknown type in declare " body)
		    '()
		    )
		`(begin
		   (dec-array ,(cons 'c-pointer newtype) ,vpfx-name . ,len)
		   (set! ,vpfx-name ,name)
		   )
		  )
		)
	      '()
	      )
	   )
	)
      (('inner-def-accu-var type name val)
	`(declare ,type (,name (+ . ,(obtain_var_vecref_lst val numveclen))))
	)
      (('force-v-set! x y) (guard (eq? cont 'sca))
	(self `(inner-for ,ivtmp (set! ,x ,y)) env 'sca)
	)
      (('remainder ivar veclen) (guard (and (eq? ivar innervar) (eq? veclen numveclen) ))
	ivtmp
	)
      ;(('vector-ref var lst))
      (('set! x y) (guard (eq? cont 'sca))
	(define typex (find-type x env 'm-v))
	;(define typey (find-type y env 'm-v))
	;(write (list body (ifcontains_inner (list x y) innervar)) current-error-port) (write-string "\n" current-error-port)
	(if (and (or (eq? typex varnotbound) (not (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv))))  (not (ifcontains_inner (list x y) innervar))) 
	  `(set! ,x ,(self y env 'acc))
	  (if (or (ifcontains_inner (list x y) innervar) (eq? type-env #f)) 
	    (self `(inner-for ,ivtmp (set! ,x ,y)) env 'sca)
	    `(set! ,(self x env 'simd)  ,(self y env 'simd))
	    ))
	)
      (('set! x y) (guard (and (eq? cont 'vec) (not (eq? (find-type x env 'm-v) varnotbound))))
	;(define typex (find-type x env 'm-v))
	;(write (list 'set-bug body typex) current-error-port) (write-string "\n")
	`(set! ,(self x env 'vec) ,(self y env 'vec))
	)
      (('inner-for ivtmp expr)
	`(block
	   (begin
	   (declare (int) ,ivtmp)
	   ;(pure-text "\n#pragma ivdep\n")
	   ;(pure-text "\n#pragma clang loop vectorize(enable)\n")
	   ;(pure-text ,(multi-concat "\n#pragma omp simd\n"))
	   (for (set! ,ivtmp 0) (< ,ivtmp ,numveclen) (set! ,ivtmp (+ ,ivtmp 1))
	     (block 
	       (begin 
		 ,(self expr (add-empty-env-layer env) 'vec)))
	     ))
	   )
	)
      (('begin x) (list 'begin (self x env cont)))
      (('begin x . y) `(begin ,(self x env cont) . ,(cdr (self `(begin . ,y) env cont))))
      (('inner-for-from-to var from to . body) (guard (eq? cont 'sca))
	(define tmpsym var)
	`(block
	   (begin
	   (declare (int) ,tmpsym)
	   (pure-text "\n#pragma clang loop vectorize(disable)\n")
	   (for (set! ,tmpsym ,from) (< ,tmpsym ,to) (set! ,tmpsym (+ ,tmpsym 1))
	     (block 
	       (begin
		 ,(self (cons 'begin body) (add-empty-env-layer env) cont)))
	     ))
	   )
	)
      (('reduce b-operator var) (guard (or (eq? cont 'sca) (eq? cont 'acc)))
	(define typex (find-type var env 'm-v))
	(if (eq? typex varnotbound)
	  var
	  (let loop ((n 0))
	    (cond
	      ((< n (- numveclen 1)) (list b-operator `(vector-ref ,var ,n) (loop (+ n 1))))
	      ((= n (- numveclen 1)) `(vector-ref ,var ,n))
	      (else '())
	      )
	    )
	  )
	)
      ;(('vector-set! vvar n expr) (guard (and (eq? cont 'sca) (let ((typex (find-type vvar env))) (eq? typex varnotbound)))) body)
      (('vector-ref vvar n) ;(vector-set!/ref vvar n . expr) 
	(guard 
	  ;(write cont current-error-port) (newline current-error-port)
	  ;(write (find-type `(vector-ref ,vvar 0) env 'm-v) current-error-port) (newline current-error-port)
	  (and (eq? cont 'vec) 
	    (let ((typex (find-type `(vector-ref ,vvar 0) env 'm-v))) 
	      (and (not (eq? typex varnotbound)) (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv) (null? (cddr typex)))))))
	;(write body current-error-port) (newline current-error-port)
	`(vector-ref (vector-ref ,(self vvar env cont) ,(self n env cont)) ,ivtmp)
	)
      ((func . args) (guard (eq? cont 'simd))
	(patmatch body
	  (('pow x num) (guard (and (number? num) (eq? (floor num) num)))
	    (define inum (if (fixnum? num) num (integer-floor num)))
	    (if (< inum 0) (set! inum (- inum)) 0)
	    (define powed
	      (cons '*
		(let loop ((x x) (inum inum))
		  (cond
		    ((eq? inum 1) x)
		    (else
		      (cons x (loop x (- inum 1)))
		      )
		    )
		  )))
	    (if (< inum 0) `(/ 1.0 ,x) x)
	    )
	  ((arthimetic-ops . args) (guard (isinlst arthimetic-ops operator-2s-lst))
	    `(,arthimetic-ops . ,(map (lambda (x) (self x env cont)) args))
	    )
	  (('vector-ref vec num) (guard (not (ifcontains_inner (list vec num) innervar)))
	    `(vector-ref ,(self vec env cont) ,(self num env cont))
	    )
	  (x ;(define s) (define def-type (fast-find-var-in-single-env 'double type-env))
	    (define ret 
	      (self 
	      `(block 
		 (begin 
		   (declare (double) tmp_var_1171_vecr)
		   (force-v-set! tmp_var_1171_vecr ,x)
		   )) env 'sca))
	    (set-car! (cdr ret) 
	      (append (cadr ret) 
		`((vector-ref ,(concat vec-prefix 'tmp_var_1171_vecr) 0))))
	    ret
	    )
	  )
	)
      ((func . args) (guard (eq? cont 'sca))
	(self `(inner-for ,ivtmp (,func . ,args)) env 'sca)
	)
      ((func . args) (guard (or (eq? cont 'vec) (eq? cont 'acc)))
	;(write (list 'fun body) current-error-port) (write-string "\n" current-error-port)
	;`(,func . ,(map (lambda (x) (self x env cont)) args))
	(map (lambda (x) (self x env cont)) body)
	)
      (x (guard (and (eq? x innervar) (eq? cont 'vec)))
	`(+ ,x ,ivtmp)
	)
      (x (guard (and (symbol? x) (or (eq? cont 'vec) (eq? cont 'simd))))
	(define typex (find-type x env))
	;(write (list typex cont (and (pair? (cdr typex)) (pair? (cddr typex)) (eq? (caddr typex) 'm-v))) current-error-port) (write-string "\n" current-error-port)
	;(if (eq? cont 'simd))
	(if (or (eq? typex varnotbound) (and (pair? (cdr typex)) (pair? (cddr typex)) (eq? (caddr typex) 'm-v)))
	  (if (eq? cont 'simd)
	    `(vector-ref ,(concat vec-prefix x) 0)
	    x)
	  (if (eq? cont 'vec)
	    `(vector-ref ,x ,ivtmp)
	    `(vector-ref ,(concat vec-prefix x) 0)
	    )
	  )
	)
      (x x)
      )
    )
  )
   
(define (expand-parafor-cpu-simd innervar varfrom varto body outenv numveclen alignlen type-map simd-len main_fp_type)
  (define type-env 
    (if (null? type-map)
      #f
      (fast-make-single-env-from-var-and-val type-map)))
  (define set-single (fast-find-var-in-single-env 'set-single type-env))
  (define ori-numveclen numveclen)
  (set! numveclen (* numveclen simd-len))
  (define (broadcast_scalar y)
    `(,(car set-single) .  
       ,(let loop ((num ori-numveclen)) 
	  (cond 
	    ((eq? num 0) '())
	    (else (cons y (loop (- num 1))))
	    )))
    `(- ,y (type-convert ,(fast-find-var-in-single-env main_fp_type type-env) (pure-text "{}")))
    )

  (define vec-prefix 'VPFX_)
  (define (force-simd-ver lst decl-proc env env_simd inner-simd-id num-simd-expand isinblock)
    ;(write-string "USE_ICC=" current-error-port) (write g_use_icc_simd current-error-port) (newline  current-error-port)
    (let self ((lst lst) (cont 'simd))
      ;(write (list lst cont) current-error-port) (newline current-error-port)
      (patmatch lst
	(('vector-ref arr n) 
	  (cond
	    ((eq? cont 'simd)
	      (define typex (find-type lst env 'm-v))
	      (define typesimd (find-type lst env_simd 'm-v))
	      (if (not (eq? typesimd varnotbound)) (set! typex typesimd) 0)
	      (if (or (eq? typex varnotbound) (not (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv))))
		(if g_use_icc_simd
		  (broadcast_scalar lst)
		  lst
		  )
		(begin
		  (define typex (if isinblock (find-type lst env_simd 'm-v) varnotbound))
		  (if isinblock (begin (write (list lst typex isinblock) current-error-port) (newline current-error-port)) 0)
		  (if (or (not isinblock) (eq? typex varnotbound) (not (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv))))
		    `(vector-ref ,(self arr 'inner-simd) (+ (* ,n ,num-simd-expand) ,inner-simd-id))
		    `(vector-ref ,(self arr 'inner-simd) ,n)
		    )) 
		))
	    (else 
	      `(vector-ref ,(self arr cont) ,n)
	      )
	    )
	  )
	;(('IS_IN_SIMD) ())
	(('dec-array . c)
	  (if isinblock (decl-proc lst env_simd)
	    (if (eq? inner-simd-id 0)
	      (decl-proc lst env)
	      '()
	      )
	    )
	  )
	(('declare type (var init))
	  `(begin 
	     ,(self `(declare ,type ,var) cont)
	     ,(self `(set! ,var ,init) cont)
	     )
	  )
	(('declare . c) 
	  ;(write (list lst isinblock) current-error-port) (newline current-error-port)
	  (if isinblock (decl-proc lst env_simd)
	    (if (eq? inner-simd-id 0)
	      (decl-proc lst env)
	      '()
	      )
	    )
	  )
	(('begin . r) `(begin . ,(map (lambda (x) (self x cont)) r)))
	(('pow x n) (guard (and (number? n) (eq? (floor n) n)))
	  (if (fixnum? n) 0 (set! n (integer-floor n)))
	  (cond
	    ((< n 0) `(block (/ 1.0 ,(self `(pow ,x ,(- n)) cont))))
	    ((eq? n 1) (self x cont))
	    (else `(* ,(self x cont) ,(self `(pow ,x ,(- n 1)) cont)))
	    )
	  )
	(('set! x y) (guard (and (number? y) (eq? cont 'simd)))
	  `(set! ,(self x cont) ,(broadcast_scalar y))
	  )
	((block-cblock body) (guard (isinlst block-cblock '(block cblock)))
	  (define old-veclen numveclen)
	  (set! numveclen ori-numveclen)
	  (define fcsivl 
	    (force-simd-ver body 
	      decl-proc env (add-empty-env-layer env_simd #t) inner-simd-id num-simd-expand #t))
	  (set! numveclen old-veclen)
	  `(,block-cblock
	     ,fcsivl)) ; HaHaHa
	((prim-funs . args) (guard (isinlst prim-funs '(+ - * / remainder b-xor b-and b-or and or semicolon)))
	  `(,prim-funs . ,(map (lambda (x) (self x cont)) args))
	  )
	((fun . args) (guard (and (symbol? fun) (not (eq? (fast-find-var-in-single-env fun type-env) varnotbound))))
	  (define newfun (car (fast-find-var-in-single-env fun type-env)))
	  `(,newfun . ,(map (lambda (x) (self x cont)) args))
	  )
	;((fun . args) (guard (and (symbol? fun) (isinlst fun '(declare-scalar-int declare-scalar-float declare-scalar-double define-long declare-long declare-double))) ))
	;(('for x0 x1 x2 . expr) `(for ,x0 ,x1 ,x2 ,(self `(begin . ,expr) cont)))
	;(('declare type var) lst)
	((x . y) `(,x . ,(map (lambda (x) (self x cont)) y)))
	(x (guard (symbol? x))
	  (cond
	    ((eq? cont 'simd)
	      (define typex (find-type x env 'm-v))
	      (define typesimd (find-type x env_simd 'm-v))
	      (if (not (eq? typesimd varnotbound)) (set! typex typesimd) 0)
	      (if (or (eq? typex varnotbound) (not (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv))))
		(if g_use_icc_simd
		  (broadcast_scalar x)
		  x)
		(begin
		  (define typex (if isinblock (find-type x env_simd 'm-v) varnotbound))
		  ;(if isinblock (begin (write (list x typex isinblock) current-error-port) (newline current-error-port)) 0)
		  (if (or (not isinblock) (eq? typex varnotbound) (not (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv))))
		    `(vector-ref ,(self x 'inner-simd) ,inner-simd-id)
		    `(vector-ref ,(self x 'inner-simd) 0)
		    )
		  )
		))
	    ((eq? x innervar) x)
	    (else
	      (concat vec-prefix x)
	      )
	    )
	  )
	(x (guard (eq? x '())) lst)
	(x (if (and (eq? cont 'simd) g_use_icc_simd) (broadcast_scalar x) x))
	)
      )
    )
  ;(define inner-var-simd (concat ))
  (let self ((body body) (env (list (fast-make-single-env-from-var-and-val `((funtmpsym_77101 v . int))))) (cont 'sca)) ;cont can be 'sca or 'vec
    ;(write (list body cont)) (newline)
    (patmatch body
      (('declare type (name init))
	(self `(begin (declare ,type ,name) (set! ,name ,init)) env cont)
	)
      ;(('declare type (name ini)))
      (('declare type name) (guard (eq? (car type) 'scalar))
	`(declare ,(cdr type) ,name)
	)
      (('IS_IN_VEC_LOOP) (self 1 env cont))
      (('force-simd-ver ('inner-simd-comp g) . y)
	 (if (eq? type-env #f)
	  (self `(begin . ,y) env cont)
	  `(begin . ,(map (lambda (x) (force-simd-ver x (lambda (y env) (self y env cont)) env (add-empty-env-layer '() #t) g simd-len #f)) y))
	   )
	)
      (('force-simd-ver . y) ;(guard (not (eq? type-env #f)))
	(if (eq? type-env #f)
	  (self `(begin . ,y) env cont)
	  `(begin . 
	     ,(map 
		(lambda (x) 
		  (cons 'begin
		    (let loop ((n 0))
		      (if (eq? n simd-len) '()
			(cons
			  (force-simd-ver x (lambda (y env) (self y env cont)) env (add-empty-env-layer (add-empty-env-layer '()) #t) n simd-len #f) 
			  (loop (+ n 1))
			  )))
		     )) 
		y))
	  )
	)
      (('declare type name)
	(add-binding-in-single-env (cons name (list type 'm-vv)) (car env))
	`(begin 
	   ,(if (not (eq? type-env #f)) 
	      (begin 
		(define newtype (fast-find-var-in-single-env (car (reverse type)) type-env))
		(if (eq? newtype varnotbound)
		  (error-h "Error: unknown simd type in declare " body)
		  0
		  )
		;(write newtype current-error-port) (write-string "\n" current-error-port)
		`(begin 
		   (dec-array ,newtype ,(concat vec-prefix name) 1) ;Now the multi-simd support is ignored
		   (declare ,(append type '(*)) (,name ,(concat vec-prefix name)))
		   )
		)
	      `(dec-array ,(if (eq? alignlen 0) type (cons alignlen type)) ,name ,numveclen)
	      )
	   )
	)
      ((block-or-cblock ('begin . y)) (guard (isinlst block-or-cblock '(block cblock)))
	`(,block-or-cblock ,(self `(begin . ,y) (add-empty-env-layer env) cont))
	)
      (('dec-array type name len)
	(add-binding-in-single-env (cons name (append (list type 'm-vv) (map (lambda (x) 'm-v) (list len)))) (car env))
	`(begin
	   ,(if (not (eq? type-env #f))
	      (begin
		(define newtype (fast-find-var-in-single-env (car (reverse type)) type-env))
		(define vpfx-name (concat vec-prefix name))
		(if (eq? newtype varnotbound)
		  (begin 
		    (error-h "Error: unknown simd type in declare " body)
		    '()
		    )
		  `(begin
		     (dec-array ,newtype ,vpfx-name ,len)
		     (dec-array ,(cons 'c-pointer type) ,name ,numveclen)
		     (set! ,name ,vpfx-name)
		     )
		  )
		)
	      `(dec-array ,(if (eq? alignlen 0) type (cons alignlen type)) ,name . ,(append (list len) (list numveclen)))
	      )
	   )
	)
      (('dec-array type name . len)
	(add-binding-in-single-env (cons name (append (list type 'm-vv) (map (lambda (x) 'm-v) len))) (car env))
	`(begin
	   ,(if (not (eq? type-env #f))
	      (begin
		(define newtype (fast-find-var-in-single-env (car (reverse type)) type-env))
		(define vpfx-name (concat vec-prefix name))
		(if (eq? newtype varnotbound)
		  (begin 
		    (error-h "Error: unknown type in declare " body)
		    '()
		    )
		  `(begin
		     (dec-array ,newtype ,vpfx-name . ,len)
		     (dec-array ,(cons 'c-pointer type) ,name . ,(append (reverse (cdr (reverse len))) (list numveclen)))
		     (set! ,name ,vpfx-name)
		     )
		  )
		)
	      `(dec-array ,(if (eq? alignlen 0) type (cons alignlen type)) ,name . ,(append len (list numveclen)))
	      )
	   )
	)
      (('inner-def-accu-var type name val)
	`(declare ,type (,name (+ . ,(obtain_var_vecref_lst val numveclen))))
	)
      (('force-v-set! x y) (guard (eq? cont 'sca))
	(self `(inner-for ,ivtmp (set! ,x ,y)) env 'sca)
	)
      (('remainder ivar veclen) (guard (and (eq? ivar innervar) (eq? veclen numveclen)))
	ivtmp
	)
      ;(('vector-ref var lst))
      (('set! x y) (guard (eq? cont 'sca))
	(define typex (find-type x env 'm-v))
	;(define typey (find-type y env 'm-v))
	;(write (list body (ifcontains_inner (list x y) innervar)) current-error-port) (write-string "\n" current-error-port)
	(if (and (or (eq? typex varnotbound) (not (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv))))  (not (ifcontains_inner (list x y) innervar))) 
	  `(set! ,x ,(self y env 'acc))
	  (self `(inner-for ,ivtmp (set! ,x ,y)) env 'sca)
	  )
	)
      (('set! x y) (guard (and (eq? cont 'vec) (not (eq? (find-type x env 'm-v) varnotbound))))
	;(define typex (find-type x env 'm-v))
	;(write (list 'set-bug body typex) current-error-port) (write-string "\n")
	`(set! ,(self x env 'vec) ,(self y env 'vec))
	)
      (('inner-for ivtmp expr)
	`(block
	   (begin
	     (declare (int) ,ivtmp)
	     ;(pure-text "\n#pragma ivdep\n")
	     ;(pure-text "\n#pragma clang loop vectorize(enable)\n")
	     ;(pure-text ,(multi-concat "\n#pragma omp simd\n"))
	     (for (set! ,ivtmp 0) (< ,ivtmp ,numveclen) (set! ,ivtmp (+ ,ivtmp 1))
	       (block 
		 (begin 
		   ,(self expr (add-empty-env-layer env) 'vec)))
	       ))
	   )
	)
      (('begin x) (list 'begin (self x env cont)))
      (('begin x . y) `(begin ,(self x env cont) . ,(cdr (self `(begin . ,y) env cont))))
      (('inner-for-from-to var from to . body) (guard (eq? cont 'sca))
	(define tmpsym var)
	`(block
	   (begin
	     (declare (int) ,tmpsym)
	     (pure-text "\n#pragma clang loop vectorize(disable)\n")
	     (for (set! ,tmpsym ,from) (< ,tmpsym ,to) (set! ,tmpsym (+ ,tmpsym 1))
	       (block 
		 (begin
		   ,(self (cons 'begin body) (add-empty-env-layer env) cont)))
	       ))
	   )
	)
      (('reduce b-operator var) (guard (or (eq? cont 'sca) (eq? cont 'acc)))
	(define typex (find-type var env 'm-v))
	(define fdtpx (multi-concat 'reduce_ b-operator '_ (caar typex)))
	(define type-reduce-fun (fast-find-var-in-single-env fdtpx type-env))
	;(write fdtpx current-error-port) (newline current-error-port)
	(if (eq? typex varnotbound)
	  var
	  (if (eq? type-reduce-fun varnotbound)
	    (let loop ((n 0))
	      (cond
		((< n (- numveclen 1)) (list b-operator `(vector-ref ,var ,n) (loop (+ n 1))))
		((= n (- numveclen 1)) `(vector-ref ,var ,n))
		(else '())
		)
	      )
	    `(,(car type-reduce-fun) (vector-ref ,(concat vec-prefix var) 0))
	    )
	  )
	)
      ;(('vector-set! vvar n expr) (guard (and (eq? cont 'sca) (let ((typex (find-type vvar env))) (eq? typex varnotbound)))) body)
      (('vector-ref vvar n) ;(vector-set!/ref vvar n . expr) 
	(guard 
	  ;(write cont current-error-port) (newline current-error-port)
	  ;(write (find-type `(vector-ref ,vvar 0) env 'm-v) current-error-port) (newline current-error-port)
	  (and (eq? cont 'vec) 
	    (let ((typex (find-type `(vector-ref ,vvar 0) env 'm-v))) 
	      (and (not (eq? typex varnotbound)) (and (pair? (cdr typex)) (eq? (cadr typex) 'm-vv) (null? (cddr typex)))))))
	;(write body current-error-port) (newline current-error-port)
	`(vector-ref (vector-ref ,(self vvar env cont) ,(self n env cont)) ,ivtmp)
	)
      (('force-scalar-ver expr) expr)
      ((func . args) (guard (eq? cont 'sca))
	(self `(inner-for ,ivtmp (,func . ,args)) env 'sca)
	)
      ((func . args) (guard (or (eq? cont 'vec) (eq? cont 'acc)))
	;(write (list 'fun body) current-error-port) (write-string "\n" current-error-port)
	;`(,func . ,(map (lambda (x) (self x env cont)) args))
	(map (lambda (x) (self x env cont)) body)
	)
      (x (guard (and (eq? x innervar) (eq? cont 'vec)))
	`(+ ,x ,ivtmp)
	)
      (x (guard (and (symbol? x) (eq? cont 'vec) ))
	(define typex (find-type x env))
	;(write (list typex cont (and (pair? (cdr typex)) (pair? (cddr typex)) (eq? (caddr typex) 'm-v))) current-error-port) (write-string "\n" current-error-port)
	;(if (eq? cont 'simd))
	(if (or (eq? typex varnotbound) (and (pair? (cdr typex)) (pair? (cddr typex)) (eq? (caddr typex) 'm-v)))
	  x
	  `(vector-ref ,x ,ivtmp)
	  )
	)
      (x x)
      )
    )
  )

(define output_method 'C)
