(define (pass0-remove-condmacros prog)
  (let self ((prog prog))
    (patmatch prog
      (('condmacro ('else . cl)) (self `(cond (else . ,cl))))
      (('condmacro (p1 . cl) . y) (self `(ifmacro ,p1 ,(cons 'begin cl) (condmacro . ,y))))
      (('conddefmacro (p1 . cl) . y) (self `(ifdefmacro ,p1 ,(cons 'begin cl) (conddefmacro . ,y))))
      (('condndefmacro (p1 . cl) . y) (self `(ifndefmacro ,p1 ,(cons 'begin cl) (condndefmacro . ,y))))
      (('cond ) (self 0))
      (('cond ('else . cl)) (self (cons 'begin cl)))
      (('cond (p1 . cl) . y) (self `(if ,p1 ,(cons 'begin cl) (cond . ,y))))
      ((condexp . g) (guard (isinlst condexp '(cond condmacro conddefmacro condndefmacro))) (error-h "Error: Invalid cond: " prog 0))
      ((x . y)
	(map self prog)
	)
      (x x)
      )
    )
  )
(define (pass1-remove-nonregdefs prog env) ;after this, only (declare type ...) and (dec-array type ...) form are allowed for declaring
  (let self ((prog prog) (env env))
    (patmatch prog
      (('define x y) (define type (find-type y env))
	(if (eq? type varnotbound) (error-h "Error: unable to decide the type: " (list x y) 0) 0)
	(self `(declare ,type (,x ,y)) env)
	)
      (('declare type (name init))
	(self `(begin (declare ,type ,name) (set! ,name ,init)) env)
	)
      (('let () . y)
	(self `(block . ,y) env)
	)
      (('block . y)
	(self (cons 'begin y) (add-empty-env-layer env))
	)
      (('set! ('vector-ref x n) y)
	(self `(vector-set! ,x ,n ,y) env)
	)
      (('declare type name) 
	;`(dec-array ,type ,name ,numveclen)
	(add-binding-in-single-env (cons name type) (car env))
	prog
	)
      (('declare type name . rest)
	(self `(begin (declare ,type ,name) (declare ,type . ,rest)) env)
	)
      ((defines y init) (guard (isdefine? defines))
	(self `(begin (,defines ,y) (set! ,y ,init)) env)
	)
      ((defines y) (guard (isdefine? defines))
	(define type (get-type-define defines))
	(self `(declare ,type ,y) env)
	)
      ((declares x . y) (guard (isdeclare? declares))
	(define type (get-type-declare declares))
	(self (append `(begin `(declare ,type x)) (if (pair? x) `(,(cons 'set! x)) '()) `((,declares . ,y))) env)
	)
      ((declares ) (guard (isdeclare? declares))
	'()
	)
      ((x . y)
	(map (lambda (x) (self x env)) prog)
	)
      (x x)
      )
    )
  )
(define ivtmp 'inner_var_G0)
(define (obtain_var_vecref_lst val numveclen . use-ghost)
  (define ug (if (null? use-ghost) #f (car use-ghost)))
  (let loop ((n 0))
    (if (= n numveclen) '()
      (cons `(* (vector-ref ,val ,n) ,(if ug `(vector-ref parafor_one_vec ,n) 1)) (loop (+ n 1)))
      )
    )
  )
(define (pass2-expand-parafor innervar varfrom varto body outenv numveclen)
  (let self ((body body) (env (list (fast-make-single-env-from-var-and-val `((funtmpsym_77101 v . int))))) (cont 'sca)) ;cont can be 'sca or 'vec
    (patmatch body
      (('declare type name)
	(add-binding-in-single-env (cons name (cons 'v type)) (car env))
	`(dec-array ,type ,name ,numveclen)
	)
      ((block-or-cblock ('begin . y)) (guard (isinlst block-or-cblock '(block cblock)))
        `(,block-or-cblock ,(self `(begin . ,y) (add-empty-env-layer env) cont))
	)
      (('dec-array type name len)
	(add-binding-in-single-env (cons name (cons 'vv type)) (car env))
	`(dec-array ,type ,name ,len ,numveclen)
	)
      (('inner-def-accu-var type name val)
	`(declare ,type (,name (+ . ,(obtain_var_vecref_lst val numveclen))))
	)
      (('set! x y) (guard (eq? cont 'sca))
	(define typex (find-type x env))
	(if (eq? typex varnotbound) `(set! ,x ,y)
	  (self `(inner-for ,ivtmp (set! ,x ,y)) env 'sca)
	  )
	)
      (('set! x y) (guard (eq? cont 'vec))
	`(vector-set! ,x ,ivtmp ,(self y env 'vec))
	)
      (('inner-for ivtmp expr)
	`(block
	   (declare int ,ivtmp)
	   ;(pure-text "\n#pragma ivdep\n")
	   (for (set! ,ivtmp 0) (< ,ivtmp ,numveclen) (set! ,ivtmp (+ ,ivtmp 1))
	     ,(self expr env 'vec)
	     )
	   )
	)
      (('begin x) (list 'begin (self x env cont)))
      (('begin x . y) `(begin ,(self x env cont) . ,(cdr (self `(begin . ,y) env cont))))
      (('inner-for-from-to var from to . body) (guard (eq? cont 'sca))
	(define tmpsym var)
	`(block
	   (declare-int ,tmpsym)
	   (pure-text "\n#pragma novector\n")
	   (for (set! ,tmpsym ,from) (< ,tmpsym ,to) (set! ,tmpsym (+ ,tmpsym 1))
	     ,(self (cons 'begin body) env cont)
	     )
	   )
	)
      ;(('vector-set! vvar n expr) (guard (and (eq? cont 'sca) (let ((typex (find-type vvar env))) (eq? typex varnotbound)))) body)
      ((vector-set!/ref vvar n . expr) 
	(guard 
	  (and (eq? cont 'vec) 
	    (isinlst vector-set!/ref '(vector-set! vector-ref)) 
	    (let ((typex (find-type vvar env))) 
	      (and (not (eq? typex varnotbound)) (eq? (car typex) 'vv)))))
	`(,vector-set!/ref (vector-ref ,vvar ,(self n env cont)) ,ivtmp . ,(map (lambda (x) (self x env cont)) expr))
	)
      ((func . args) (guard (eq? cont 'sca))
	(self `(inner-for ,ivtmp (,func . ,args)) env 'sca)
	)
      ((func . args) (guard (eq? cont 'vec))
	`(,func . ,(map (lambda (x) (self x env cont)) args))
	)
      (x (guard (and (eq? x innervar) (eq? cont 'vec)))
	`(+ ,x ,ivtmp)
	)
      (x (guard (and (symbol? x) (eq? cont 'vec)))
	(define typex (find-type x env))
	(if (eq? typex varnotbound)
	  x
	  `(vector-ref ,x ,ivtmp)
	  )
	)
      (x x)
      )
    )
  )
(define (pass2-shell prog)
  (pass2-expand-parafor 'g 0 24 prog '() 4)
  )
(define (pass-remove-blocks-returns-for-stupid-opencl-compilers expr)
  (define ret-preblock '())
  ;(write expr current-error-port) (write-string "\n" current-error-port)
  (define new-expr 
    (let self ((expr expr))
      (patmatch expr
	((c/block ('begin . x)) (guard (isinlst c/block '(cblock block))) (define newsym (gensym))
	  (define x-rev (reverse x))
	  (define x-last (list 'set! newsym (car x-rev)))
	  (set! x-rev `(block (begin . ,(reverse (cons x-last (cdr x-rev))))))
	  (define newx `(begin (declare (double) ,newsym) ,x-rev))
	  (set! ret-preblock 
	    (cons newx ret-preblock))
	  newsym
	  )
	((x . y) (map self expr))
	(x x)
	)
      ))
  (list ret-preblock new-expr)
  )
