;(define (mypow n x y)
; (cond 
;  ((= n 0) y)
;  ((even? n) (square (mypow x (/ n 2))))
;  (else (* x (mypow x (- n 1))))))
(define name 'mypow)
;(define args (args-of-lambda mypow))
;(define body (body-of-lambda mypow))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;repl;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (selfeval? expr)
 (or (number? expr) (null? expr) (string? expr) (char? expr) (boolean? expr)))
(define (constant? expr)
 (or (selfeval? expr) (and (pair? expr) (eq? (car expr) 'quote))))
(define (constant-eval expr)
 (cond ((selfeval? expr) expr)
  (else (cadr expr))))
(define (istag expr tag)
 (and (pair? expr) (eq? (car expr) tag)))
(define closure-flag (gensym))
(define var-not-bound-sym (gensym))
(define empty-env '())
(define (make-begin expr)
 (cons 'begin expr))
(define prim-proc-symbols
 '(+ - * / = eq? cons pair? null? number? boolean? char? string? symbol? list write car cdr square istag))
;(define prim-proc-bodys (map eval prim-proc-symbols))
(define prim-proc-bodys
 (list + - * / = eq? cons pair? null? number? boolean? char? string? symbol? list write car cdr square istag))
(define anytimeevalable (list cons))
(define (generate-prim-proc symbs bodys)
 (cond ((null? symbs) '())
  (else (cons (cons (car symbs) (car bodys)) (generate-prim-proc (cdr symbs) (cdr bodys))))))
(define prim-proc-envs (generate-prim-proc prim-proc-symbols prim-proc-bodys))

(define (init-env)
 (let ((env0 empty-env))
  (set! env0 (cons prim-proc-envs env0))
  env0))
(define (find-var-in-single-env var env)
 (cond ((null? env) var-not-bound-sym)
  ((eq? (caar env) var) (cdar env))
  (else (find-var-in-single-env var (cdr env)))))


(define (make-closure args body env)
 (list closure-flag args body env))
(define (getargs-of-closure clo)
 (cadr clo))
(define (getbody-of-closure clo)
 (caddr clo))
(define (getenv-of-closure clo)
 (cadddr clo))
(define error-report
 (lambda (expr)
  (write-string expr)(newline)))
(define (find-var-in-env var env)
 (cond ((null? env) ;(write-string "warning: variable is not bounded\nvar name=") (write var) (error-report "")
	var-not-bound-sym)
  (else 
   (let ((vfind (find-var-in-single-env var (car env)))) 
    (cond ((eq? vfind var-not-bound-sym) (find-var-in-env var (cdr env)))
     (else vfind))))))
(define (make-single-env-from-var-and-val vars vals)
 (cond ((null? vars) '())
  ((pair? vars) 
   (cond 
    ((pair? vals) (cons (cons (car vars) (car vals)) (make-single-env-from-var-and-val (cdr vars) (cdr vals))))
    (else error-report "error: vals is not enough")))
  (else (cons vars vals))))
(define (setvarinsingleenv var val senv)
 (cond ((null? senv) var-not-bound-sym)
  ((eq? (caar senv) var) (set-car! senv (cons var val)))
  (else (setvarinsingleenv var val (cdr senv)))))
(define (setvar-in-env var val env)
 (cond ((null? env) (write "set error: variable is not bounded\nvar name=") (write var) (error-report ""))
  (else (cond ((eq? (setvarinsingleenv var val (car env)) var-not-bound-sym) (setvar-in-env var val (cdr env)))
	 (else 'done)))))
(define (defvar-in-senv var val senv)
 (cond ((eq? (find-var-in-single-env var senv) var-not-bound-sym) (cons (cons var val) senv))
  (else (setvarinsingleenv var val senv) senv)))

(define (is-all-binded lst)
 (cond 
  ((not (pair? lst)) #t)
  (else 
   (cond
    ((and (pair? (car lst)) (eq? (caar lst) var-not-bound-sym)) #f)
    (else (is-all-binded (cdr lst)))))))
(define issymbol symbol?)
(define (get-arg-list exprs env)
 (cond ((null? exprs) '())
  (else (cons (partial-eval (car exprs) env) (get-arg-list (cdr exprs) env)))))
(define (partial-eval expr env)
 ;(display expr) (newline)
 (cond 
  ((constant? expr) (constant-eval expr))
  ((istag expr var-not-bound-sym) expr)
  ((istag expr 'if)
   (let ((condexpr (partial-eval (cadr expr) env)))
   (cond 
    ((istag condexpr var-not-bound-sym) (cons var-not-bound-sym expr))
    (else (if condexpr (partial-eval (caddr expr) env) (partial-eval (cadddr expr) env))))))
  ((istag expr 'define) 
   (let ((defvarname (cadr expr)) (defval (partial-eval (caddr expr) env)))
    (set-car! env (defvar-in-senv defvarname defval (car env)))))
  ((istag expr 'set!) (setvar-in-env (cadr expr) (partial-eval (caddr expr) env) env))
  ((istag expr 'begin)
   (cond ((null? (cdr expr)) (error-report "error: empty-begin is not allowed") 'done)
    ((null? (cddr expr)) (partial-eval (cadr expr) env))
    (else (partial-eval (cadr expr) env) (partial-eval (make-begin (cddr expr)) env))))
  ((istag expr 'lambda) (make-closure (cadr expr) (cddr expr) env))
  ((issymbol expr) 
   (let ((var-finded (find-var-in-env expr env)))
    ;(display var-finded)(newline) 
    ;var-finded))
    (cond ((eq? var-finded var-not-bound-sym) (cons var-not-bound-sym expr)) (else var-finded))))
  ((pair? expr) 
   (let ((proc-main (partial-eval (car expr) env)) (proc-args (get-arg-list (cdr expr) env)))
    ;(display (list proc-args (is-all-binded proc-args))) (newline)
    (cond 
     ((istag proc-main var-not-bound-sym) (lcons var-not-bound-sym proc-main proc-args))
     ((not (is-all-binded proc-args))
      (cond 
       ((isinlst proc-main prim-proc-bodys)
	(cond 
	 ((not (isinlst proc-main anytimeevalable)) (cons var-not-bound-sym (cons (car expr) proc-args)))
	 (else (apply proc-main proc-args))))
       ((istag proc-main closure-flag) 
	(let ((newenv (cons (make-single-env-from-var-and-val (getargs-of-closure proc-main) proc-args) (getenv-of-closure proc-main)))) 
	   (cons var-not-bound-sym (partial-eval (make-begin (getbody-of-closure proc-main)) newenv))))
       (else 'error)))
     ;((and (not (is-all-binded proc-args))) (cons var-not-bound-sym (cons (car expr) proc-args)))
     ((isinlst proc-main prim-proc-bodys) (apply proc-main proc-args)) 
     ((istag proc-main closure-flag) 
      (let ((newenv (cons (make-single-env-from-var-and-val (getargs-of-closure proc-main) proc-args) (getenv-of-closure proc-main)))) 
	   (partial-eval (make-begin (getbody-of-closure proc-main)) newenv)))
     (else (write-string "error: unexecutable:") (write proc-main) (newline)))))
  (else 'error)))
(define (eliminate-var-not-found lst)
 (cond 
  ((not (pair? lst)) lst)
  ((istag lst var-not-bound-sym) (eliminate-var-not-found (cdr lst)))
  (else (cons (eliminate-var-not-found (car lst)) (eliminate-var-not-found (cdr lst))))))
(define (partial-eval-interface expr)
 (let ((env0 (init-env)))
  ;(partial-eval '(define cons (lambda (a b) (innercons a b))) env0)
  (partial-eval expr env0)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;end-repl;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(define (generate-partial-n-is-know n)
; `(lambda (x y) 
;	 ,(cond ((= n 0) 'y)
;		 ((even? n) `(square (,(generate-partial-n-is-know (/ n 2)) x y)))
;		 (else `(* x (,(generate-partial-n-is-know (- n 1)) x y))))))
(define replace-all-exclude
 (lambda (lst from to exclude)
  (cond
   ((null? lst) '())
   ((and (pair? lst) (not (isinlst (car lst) exclude))) (cons (replace-all-exclude (car lst) from to exclude) (replace-all-exclude (cdr lst) from to exclude)))
   (else 
    (cond ((eq? lst from) to) 
     (else lst))))))
	;(let ((final-opt (removing-vars (cddar form) var)))
	  ;(cond ((null? (cdr final-opt)) (car final-opt))
	   ;(else (cons 'begin final-opt))))

(define (removing-empty-lambda form)
 (cond
  ((null? form) '())
  ((and (pair? form) (pair? (car form)) (eq? (caar form) 'lambda) (eq? (cadar form) '()))
   (let ((final-opt (removing-empty-lambda (cddar form))))
    (cond ((null? (cdr final-opt)) (car final-opt)) 
     (else (cons 'begin final-opt)))))
  ((pair? form) (cons (removing-empty-lambda (car form)) (removing-empty-lambda (cdr form))))
  (else form)))

(define (removing-var form var)
 ;(display form)(newline)
 (cond 
  ((null? form) '())
  ((and (pair? form) (pair? (car form)) (eq? (caar form) 'lambda) (pair? (cadar form)) (isinlst var (cadar form)) (pair? (cdr form)) (isinlst var (cdr form))) (cons (lcons 'lambda (delete-from-list var (cadar form)) (removing-var (cddar form) var)) (delete-from-list var (cddr form))))
  ((pair? form) (cons (removing-var (car form) var) (removing-var (cdr form) var)))
  (else form)))
(define (removing-vars form vars)
 (cond 
  ((null? vars) form)
  (else (removing-vars (removing-var form (car vars)) (cdr vars)))))

