(define macros-interp '(0))
(defmacro read-infile ()
 '(read infile)
)
(define (read-all infile)
 (let loop ((l1 (read-infile)) (curlst '()))
   (cond ((eof-object? l1) (set! macros-interp (cons 'begin (reverse macros-interp))) (cons 'begin (reverse curlst)))
     ((eq? (car l1) 'defmacro) (set! macros-interp (cons l1 macros-interp)) (loop (read-infile) curlst)) 
  (else (loop (read-infile) (cons l1 curlst))))
)
)
(define begin-map-n 
  (lambda (fun . args)
    (let ((n -1))
      (define new-fun 
	(lambda x 
	  (set! n (+ n 1))
	  (apply fun (cons n x))
	  ))
      `(begin . ,(apply map (cons new-fun args)))))
  )
(define begin-map (lambda (fun . args)
  `(begin . ,(apply map (cons fun args))))
  )
(defmacro eval-scmc-global (m) (eval-global m))
(defmacro define-scmc-global (m n) (eval-global `(define ,m ,n)) '())
(defmacro include-fun-defs (fname)
  (define fp (open-input-file fname))
  (define defs-all (read fp))
  (close-input-port fp)
  (set! defs-all (map (lambda (x) (cons 'dec-fun x)) defs-all))
  (cons 'begin defs-all)
  )
(defmacro decl-var-and-pvar (type name . init)
  (define realname (if (pair? name) (car name) name))
  (append `(begin 
     (,(concat 'declare- type) ,name)
     (,(multi-concat 'declare- type '*) (,(concat 'p realname) ("&" ,realname)))
     ) 
    (cond 
      ((null? init) '())
      (else
	`((set! ,realname . ,init))
	)
      )
    )
  )
(defmacro input-scmc (filename)
  (if (symbol? filename) (set! filename (symbol->string filename)) 0)
  (let ((fp (open-input-file filename)))
    (cons 'begin
      (let loop ((r1 (read fp)))
	(cond
	  ((eof-object? r1) '())
	  (else
	    (cons r1 (loop (read fp)))
	    )
	  )
	)
      )
    )
  )
(defmacro input-include (filename)
  (if (symbol? filename) (set! filename (symbol->string filename)) 0)
  (let ((fp (open-input-file filename))) 
    (cons 'begin
      (let loop ((cur-line (read-line fp)))
	(cond
	  ((eof-object? cur-line) '())
	  (else 
	    (cons `(pure-text ,(concat cur-line "\n")) (loop (read-line fp)))
	    )
	  )
	)))
  )
(defmacro inc (a b)
  `(set! ,a (+ ,a ,b))
  )
(defmacro parafor4 args
  `(paraforn 4 . ,args)
  )
(defmacro parafor8 args
  `(paraforn 8 . ,args)
  )
(defmacro for-from-to (id f t . body)
  `(block
     (declare-long ,id)
     (for (set! ,id ,f) (< ,id ,t) (set! ,id (+ ,id 1))
       . ,body
       )
     )
  )
(defmacro for-from-zero-to (id t . body)
  `(for-from-to ,id 0 ,t . ,body)
  )
(defmacro typedef-fun (ret arglst name)
  `(begin 
     (pure-text "typedef ")
     (declare (function-pointer ,ret . ,arglst) ,name)
     )
  )
(defmacro with-structp (strp . rest)
  `(begin .
     ,(map
	(lambda (onl)
	  (multi-define var val onl)
	  `(set! (structp-ref ,strp ,var) ,val)
	  )
	rest)
     )
  )

(defmacro TYPE_MALLOC (type len)
  `(malloc (* (sizeof ,type) ,len))
  )

(defmacro incf! (a . b)
  (if (null? b) (set! b 1) (set! b (car b)))
  `(set! ,a (+ ,a ,b))
  )
(define gen-class-header 
  (lambda (name dec)
    (cond
      ((eq? (car dec) 'dec-array)
	(multi-define type localname (cdr dec))
	`(declare ,(concat type '*) (,localname (structp-ref ,name ,localname))))
      (else
	(multi-define type localname dec)
	`(declare ,type (,localname (structp-ref ,name ,localname)))
	)
      ))
  )

(defmacro class-typedef-struct (name . decs)
  `(begin (typedef-struct ,name . ,decs)
     (defmacro ,(concat 'class-header- name) (classpointer)
       (list 'begin (lcons 'begin `(pure-text ,,(multi-concat "\n//defined from class "  (symbol->string name) "\n")) (map (lambda (x) (gen-class-header classpointer x)) (quote ,decs))) `(pure-text ,,(multi-concat "\n//===================="  (symbol->string name) "\n")))
       )
     (defmacro ,(concat 'defun-class- name) (funname rettype arglst . body)
       (lcons 'defun funname rettype (cons (list ',(concat name '*) 'pthis) arglst) '(,(concat 'class-header- name) pthis) body)
       )
     )
  ) 

(define all (read-all current-input-port))
(define macroexpand-all 
  (lambda (prog) 
    (cond 
      ((pair? prog) 
	(cond 
	  ((eq? (car prog) (quote quote)) prog) 
	  ((eq? (car prog) 'defmacro) (eval-global prog) '())
	  ((and (symbol? (car prog)) (symbol-binded? (car prog)) (macro? (eval (car prog)))) 
	    ;(write prog current-error-port) (newline current-error-port)
	    (define mcpg (macroexpand prog))
	    ;(write mcpg current-error-port) (write 'done current-error-port) (newline current-error-port)
	    (macroexpand-all mcpg))
	  (else (cons (macroexpand-all (car prog)) (mappairorlist macroexpand-all (cdr prog))))))
      (else prog))))
(eval macros-interp) 
(write  (macroexpand-all all)) 

